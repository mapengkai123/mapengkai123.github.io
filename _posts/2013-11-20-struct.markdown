---
layout: post
title:  "构造函数与析构函数"
date:   2013-11-20 14:11:38 +0800
---
<img src="/images/fulls/01.jpg" class="fit image">


构造方法 __construct():
概念： 构造方法是对象生成时自动执行的方法，一般用于初始化操作。(注:对象生成	一般是实例化对象的时候)
应用场景：
       对类中的一些变量赋值
       数据库操作类中数据库连接操作等等

定义方法:
       function __construct(){
         echo "已经连接上了数据库 可以进行增删改查的操作了";
       }


析构方法 __destruct():
概念：析构方法是对象销毁时自动执行的方法，一般用于清理程序不再使用的资源释放	内存。
1. 对象销毁时执行。
2. 什么叫销毁对象？
        $a = new Human();
$a 并不是对象，它只是一个变量名，指到对象。
unset($a) 未必销毁了对象。如果还有其他变量同时指到对象的时候
比如：$b=$c=$a=new Human();。只有所有指向对象的变量全部销毁才销毁。

应用场景：
      如操作数据库后关闭数据库连接
      使用打印机后释放打印机资源
      文件操作后释放文件资源等等
定义方法:
function __destruct(){
    echo "数据库关闭 已经释放内存了";
}
注意：php使用的是一种垃圾回收机制，自动清除不再使用的变量（包括对象）。所以	不使用unset()方法销毁对象，程序结尾变量会被销毁，析构方法会自动被调用。


使用$this访问方法和属性
我们学习过，实例化对象后，可以通过对象名来调用类中的属性和方法。
对象名->属性名
对象名->方法名() 
类的内部如需调用本类的成员属性和成员方法，可借助伪变量$this。
$this->属性名
$this->方法名()

原理：当一个对象($a)调用其方法(who())时，该方法执行之前，先完成一个绑定。就是$this绑定到调用该方法的那个对象上。

注意：$a->test();这个时候，会报错说未定义的方法。因为在方法体内想访问调用者的属性，必须用$this，如果不加$this则理解为调用方法内部的一个局部变量。

静态成员
引入：每当我new得时候就会生成一个内存空间来存储实例化后得对象。如果我new100次呢？就会使用大量空间存储实例化后的对象 怎样可以不用实例化就能访问属性和调用方法呢？使用静态成员就可以了
静态分为两个部分：静态属性和静态方法
注意：

静态方法中，只能调用静态变量，而不能调用普通变量，但普通方法中可以调用静态变量。


	静态属性
	定义静态属性：使用关键字static修饰的属性称之为静态属性。
	静态方法
	定义静态方法：使用static关键字修饰的方法叫做静态方法。

能用静态解决的问题，不用普通方法解决问题（静态的东西可以直接使用类访问，不需要通过对象实例化，因此节省了内存空间，提升了效率）。

特别注意：
严格遵循：静态的内容给类访问，非静态的是给对象访问，不要跨界操作

1. 其实非静态方法是不能由类名静态调用的，但是由于php中的面向对象检测不严格，只要该方法没有$this,就会转化为静态方法来调用，但是PHP5.3的strict模式下，或者PHP5.4默认模式下，都已经对类名::非静态方法的调用做错误。Error_reporting(E_ALL|E_STRICT);

	总结：
	类  --> 访问 --静态方法 ：可以
	类  --> 访问 --普通方法 ：不可以
	   
	对象 --> 访问 --静态方法： 可以
	对象 --> 访问 --普通方法： 可以

self与$this的区别

	1)self ：代表本类，自身（不要理解为本类的对象），$this代表对象
	2)self访问类内部的常量和静态成员，$this访问对象的属性和普通方法
	3)self必须配合范围解析操作符（::）才能生效，$this代表对象，对象本来就是一种数据类型，所以$this可以单独被打印。
	4)能用$this的地方，一定可以使用self，但是能使用self的地方不一定可以使用$this
	5)非静态的属性和方法均用对象（$this）访问，静态的方法和属性或常量均用类(self)来访问
